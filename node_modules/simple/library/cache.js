var pth = require('path');
var montharr = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'];
var cache = module.exports = function (req, res) {

	this.compression(req);
	var cc = req.headers['cache-control'];
	var prg = req.headers['pragma'];
	if (prg)
		this.prg = true;
	if (cc)
		this.cc = true;
	this.req = req;
	this.res = res;
}


cache.prototype.compression = function (req) {



	var acceptEncoding = req.headers['accept-encoding'];

	if (!acceptEncoding) {
		acceptEncoding = '';
		this.compress = false;
	}
	else {

		this.compress = true;
		if (req.headers['user-agent'].match(/trident/i) || req.headers['user-agent'].match(/edge/i)) {
			this.acceptEncoding = 'gzip';


		}
		else
			this.acceptEncoding = acceptEncoding;

	}

}


cache.prototype.cacheFile = function (fname, isview) {
	try {
		var path = '';
		var cfg = require('../../../config/systemconfig');
		if (isview)
			path = fname;
		else
			path = cfg.publicpath + '/' + fname;
		var fs = require('fs');
		var pt = require('path');
		path = pt.normalize(path);
		if (fs.existsSync(path)) {
			var stats = fs.statSync(path);
			var mtime = stats.mtime;
			var size = stats.size;

			var ms = mtime.getMilliseconds();
			// console.log(fname);

			var modSince = this.req.headers["if-modified-since"];

			//console.log(modSince, mtime.getTime());
			if (modSince) {





				var modarr = modSince.split(' ');


				var mnth = modarr[1];

				var ind = montharr.indexOf(mnth);
				var month = ind;
				var day = parseInt(modarr[2]);
				var year = parseInt(modarr[3]);
				var timearr = modarr[4].split(':');
				var hr = parseInt(timearr[0]);
				var min = parseInt(timearr[1]);
				var sec = parseInt(timearr[2]);

				modSince = new Date(year, month, day, hr, min, sec, ms);

				//console.log(modSince, 'msince', mtime);
				if (modSince.getTime() == mtime.getTime()) {

					if (this.compress !== undefined && this.compress === true) {

						this.res.statusCode = 304;
						this.res.setHeader("if-modified-since", mtime.toUTCString());
						this.res.setHeader('content-encoding', 'deflate');
					}
					else {
						this.res.statusCode = 304;
						this.res.setHeader("if-modified-since", mtime.toUTCString());
					}
					this.res.end();

					return true;
				}
				else {
					return false;
				}
			}
			{

				return false;
			}
		}
		else {
			return false;
		}

	}
	catch (err) {
		console.log(err);
	}
}

cache.prototype.writemime = function (fname, isview) {


	try {
		//console.log(fname);
		var cc;
		var ex;
		var prag;
		var obj = this;
		if (this.cc) {

			this.res.setHeader("Cache-Control", "must-revalidate, max-age=86400");
		}


		var cfg = require('../../../config/systemconfig');
		if (isview === true)
			path = fname;
		else
			var path = pth.normalize(cfg.publicpath + '/' + fname);
		var fs = require('fs');
		if (fs.existsSync(path)) {
			var stats = fs.statSync(path);
			var mtime = stats.mtime;

			var size = stats.size;

			if (this.prg) {

				this.res.setHeader('Pragma', 'cache');

			}

			//console.log(ext);
			ex = this.Expires;
			var d = new Date();
			d.setMinutes(d.getMinutes() + 1440);

			this.res.setHeader("Expires", d.toUTCString());

			//else
			//this.res.setHeader("Expires", '-1');
			this.res.setHeader('Last-Modified', mtime);
		}
		else {
			return false;
		}

	}
	catch (err) {
		console.log(err);
	}
	// console.log(mime);

}

