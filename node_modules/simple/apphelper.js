"use strict";

var http = require('http');
var https = require('https');
var util = require("util");
var url = require('url');
var path = require('path');
var cache = require('./library').cache;
let simplecontroler = require('./library').simplecontroler;
let compression = require('./library').compress;
let log = require('./library').global;

var simple = require('simple');
var simple_js = module.exports = function () {
	this.loadable = new Array();
	this.middleware = new Array();
	this.usecache = true;
}

simple_js.prototype.create = function (app) {
	var server = http.createServer(app);
	server.on('upgrade', function (req, socket, head) {

		/*var ws = require('websocket');
		//create an array to hold these objects and call senddata onit when ready
		var websoc = new ws(req, socket, head);
		websoc.upgrade(); */
	}
	);
	return server;
}

simple_js.prototype.createSecure = function (app,options) {
	var fstm = require('fs');
//	var config = require('../config/systemconfig');
	//var options = { key: fstm.readFileSynoptionsc(config.keys + '/' + 'key.pem'), cert: fstm.readFileSync(config.keys + '/' + 'cert.pem') };



	var server = https.createServer(options, app)
	server.on('upgrade', function (req, socket, head) {
	/*	var ws = require('websocket');
		//create an array to hold these objects and call senddata onit when ready
		var websoc = new ws(req, socket, head);
		websoc.upgrade();  */
	});

	//objtt = this;
	return server;
}



simple_js.prototype.createSock = function (host, port) {

	var cfg = require('simple').config;
	var netsoc = require('simplesock');
	var ws = new netsoc();
	ws.create().listen('1338');

}



simple_js.prototype.reqContent = function (pthnm, ctr, req, res, quer) {
	
	var obj = this;
	var methd = pthnm[0];
	req.callmethod = methd;
	ctr.create(res, req);
	 let routParams = pthnm.slice(0);
	pthnm.shift();
	var qs = require('querystring');
	if (req.method === 'POST' || req.method === 'PUT' || req.method === 'PATCH') {
		;
		var body = '';
		var ob = '';
		var ar = [];
		req.on('data',  (data) =>{
			try {
				body += data;
				if (body.length > 1e6) {
					body = "";
					res.writeHead(413, { 'Content-Type': 'text/plain' });
					res.end();
					req.connection.destroy();
				}
			}
			catch (err) {
				log.logerror(err);

			}
		});
		req.on('end',  ()=> {
			try {

				if (req.headers['content-type'].search('multipart/form-data') !== -1) {

					var boundry = req.headers['content-type'].split(';');

					var sep = "";

					for (var b in boundry) {
						if (boundry[b].search('boundary') !== -1) {
							var arr = boundry[b].split('=');
							sep = arr[1].trim();
						}
					}


					ctr.postdata = obj.parse_multipart(body, sep);



				}
				else {
					if (body.slice(0, 1) === '{' && body.slice(-1) === '}') {

						//TRY CATCH FOR ERRORS
						try {
							ctr.postdata = JSON.parse(body);
						}
						catch (e) {
							console.log(e);
							var BD = JSON.stringify(body)
							ctr.postdata = JSON.parse(BD);
						}


					}
					else {
						ctr.postdata = qs.parse(body);
					}
				}
                let robj = this.route(methd,ctr,pthnm,routParams, req);
				if(robj)
				  ctr[robj.funct].apply(ctr, robj.params);
			}
			catch (err) {
				log.logerror(err);
			}
		});

	}
	else {
		
		if (pthnm.lenght > 0) {

			pthnm = pthnm.map((x)=> { return this.replacesuspicioscont(x); });
			// console.log(pthnm);
		}
		if (Object.keys(quer).length !== 0) {
			

			for (var att in quer) {
				var atr = this.replacesuspicioscont(quer[att]);
				pthnm.push(atr);
				quer[att] =  atr;
			}
            
			ctr.requestdata = quer;
			

		}
		
	    let robj = this.route(methd,ctr,pthnm, routParams, req);
		if(robj)
	    	ctr[robj.funct].apply(ctr, robj.params);

	}


}
simple_js.prototype.route =  function(methd, ctr,pthnm, routParams, req)
{
    
	  let routeControler= false;
	  let routeControlerDefaults = false;
	  var controlerRoute;
	   
	   var routes;
	  
	   try{
	      routes =  require('../../config/routes');
	   }
	   catch(exc)
	   {
		  
	   }
	   
	   if(! routes || (routes.Exceptions && routes.Exceptions.indexOf(req.ctr)) !== -1) //fix
	   {
	     if(ctr['catchall'])
		   methd = 'catchall';
		   
	     return {funct: methd, params:pthnm}
	   }
	   //let route =  require('../../config/routes');
	   let controler= routes[req.ctr]
	   if(controler)
	     controlerRoute = controler[methd];
	  
	    if(controler && !controlerRoute)
		{
		 controlerRoute = controler.defaults;
		 routeControlerDefaults = true;
		}
	
		let defaultMethod = routes.AppDefaults.action;
		var routeMethod;
		if(controlerRoute)
		{
		  routeControler = true;
		  if(!routeControlerDefaults)
		    routParams =pthnm;
		}
		 
		if(routeControler || !ctr[methd] || (defaultMethod === methd))
		{  
		
			if(ctr.catchall && (defaultMethod !== methd))
			{   
		
				methd = 'catchall';
				
				
			}
			else
			{
		    var rts;
		    if(controlerRoute)
			  rts = controlerRoute;
			else
			  rts= routes.defaultRoutes;
			
			  let i = 0;
			
			  while( i < rts.length)
			  {
				 	
			   
               if(defaultMethod ===  methd && pthnm.length === 0)
			      routParams = pthnm;
			   
			    let route = rts[i];
			   
			   if(route.params.length === routParams.length)
			   {

				  
				   let mmth = route[req.method];
				   let mctr =  req.ctr.charAt(0).toUpperCase()+req.ctr.slice(1);
				   var meth;
				   if(mmth)
				     meth =mmth.replace('{{controller}}', mctr);  
				   
				   routeMethod = meth; 
				
				   break;
				  // break;
			   } 
			   i++;
			}
			if(!routeMethod || !ctr[routeMethod])
			{
			  methd =undefined;
			  this.notfound(this.resp);
			  return;
			}
			else 
			  methd = routeMethod;
			  pthnm = routParams;
			}
		}
		  
		  let ret = {funct: methd, params:pthnm};
		return ret;
}
simple_js.prototype.parse_multipart = function (body, sep) {
	var arr = [];

	var str = '';
	var lastittern = 0;
	var main = {};
	var lastitter = false;
	cnt = 0;

	var patt = /^\s*\r\n/m;
	var m;
	while (m !== null) {

		ms = '--' + sep + '--';

		if (ms.length == body.trim().length)
			break;
		if ((m = patt.exec(body)) !== null) {
			if (m.index === patt.lastIndex) {
				patt.lastIndex++;
			}

			var headervals = {};
			headers = body.substring(0, m.index);

			body = body.slice(m.index, body.length);
			data = body.substring(0, body.indexOf('--' + sep));
			body = body.slice(body.indexOf('--' + sep), body.length);
			//   console.log(headers);
			headers = headers.replace(/\r/g, '');


			var hds = headers.split('\n');
			hds.splice(0, 1);
			if (hds.length === 0)
				continue;
			var fm = hds[0].split(';');
			var spv = fm[0].split(':');
			headervals[spv[0]] = spv[1];

			for (i = 1; i < fm.length; i++) {

				firsteq = fm[i].indexOf('=');
				var n;
				if (firsteq !== -1) {
					n = fm[i].substring(0, firsteq);
					n = n.trim();
					v = fm[i].substring(firsteq + 1, fm[i].length);
				}
				headervals[n] = v;
			}
			if (hds.length > 1) {
				var ctype = hds[1];
				csp = ctype.split(':');
				headervals[csp[0]] = csp[1];
			}
			// console.log(headervals);
			if (headervals['Content-Type'] !== undefined) {

				name = headervals['name'];
				name = JSON.parse(name);

				delete headervals['name'];
				delete headervals['Content-Disposition'];
				headervals.data = data.trim();
				if (main[name] !== undefined) {
					tname = main[name];
					main[name] = [];
					main[name].push(tname);
					main[name].push(headervals);
				}
				// else if(typeof main[name] === 'object')
				// main[name].push(headervals)
				else
					main[name] = headervals
			}
			else {
				var n = headervals['name']
				n = JSON.parse(n);
				if (main[n] !== undefined && typeof main[n] !== 'object') {
					tname = main[n];
					main[n] = [];
					main[n].push(tname);
					main[n].push(data.trim());
				}
				else if (typeof main[n] === 'object')
					main[n].push(data.trim())
				else
					main[n] = data.trim();
			}
		}
	}


	return main;
}
simple_js.prototype.extractName = function (ar, val) {
	var pecies = [];

	for (var it in ar) {
		var a = ar[it].search("name=")
		if (a !== -1) {
			var rspt = ar[it].split("=");
			var mar = [];
			mar.push(rspt[1]);
			mar.push(val);


			pecies.push(mar);
			break;
		}
	}
	//console.log(pecies);
	return pecies;
}

simple_js.prototype.listen = function (port, server) {
	var srv = server;
	var prt = port;
	srv = typeof srv !== 'undefined' ? srv : '0.0.0.0';
	prt = typeof prt !== 'undefined' ? prt : 80;
	this.server.listen(prt, srv);
}
simple_js.prototype.securelisten = function (port,server) {
	var srv = server;
	var prt = port;
	srv = typeof srv !== 'undefined' ? srv : '0.0.0.0';
	prt = typeof prt !== 'undefined' ? prt : 4433;
	this.secureserver.listen(prt, srv);
}
simple_js.prototype.apply = function (libname, obj) {


	this.loadable.push({ lib: libname, call: obj });
	return this;

}

simple_js.prototype.loadtoreq = function (req, resp, ctr,tt) {
	var lib = '';
	var objt = this;
	try{
    if(ctr)
	{
	req.viewpath = function (vname) {

		var cfg = require('../../config/systemconfig');
		var tpath = '';
		var path1 = cfg.viewpath + '/shared/' + vname + '.html';
		
		var path2 = cfg.viewpath + '/' + req.ctr + '/' + vname + '.html';
		path1 = path.normalize(path1);
		path2 = path.normalize(path2);
		
		if (objt.findbyconvention(path1))
			return path1;
		else if (objt.findbyconvention(path2))
			return path2;
		else return tpath;
		//console.log(tpath);
		//return tpath;
	}
	}
	for (var lb in this.loadable) {

		var li = this.loadable[lb].lib;
		var lib1 = require('../../../library/' + li);
		lib = new lib1(req, resp);

		var ob = this.loadable[lb].call;
		for (var va in ob) {

			lib[va] = ob[va];
		}
		ctr[li] = lib;

		//req[li] = lib; 
		//resp[li]=lib;	
	}

	//if (this.notstatic === true) {
		var bp;
		 if(tt.indexOf('/'));
		   bp = tt.split('/')[0];
		   bp = path.normalize('/'+bp);
		
		this.middleware.forEach((mw)=> {
		
		   // console.log(mw);
			if (mw.path !== undefined && (bp !== undefined && bp == mw.path)) {
				
				mw.function(req,resp,bp);
			}
			else if (mw.path === undefined) {
				
				mw.function(req,resp);
			}


		});
//	}
	}
	catch(err){
		console.log(err);
	}



	return this;
}



simple_js.prototype.loadStatic = function (fname, req, res,base) {
    let mcache = new cache(req, res);
	if ((this.usecache && !mcache.cacheFile(fname)) || !this.usecache) {
	    let mimeSet = require('./mimetypes');
		if(this.usecache)
		  mcache.writemime(fname,false);
	
		var pt = require('path');
		var cfg = require('../../config/systemconfig');
		var fs = require('fs');
		let ppath = require('simple').staticPath;
		let fpath = cfg.publicpath + '/' + fname;
		if( ppath[base.slice(1)] && fs.existsSync( path.normalize(ppath[base.slice(1)].relpath+'/'+path.basename(fname))))
		{
		  
		  fpath = path.normalize(ppath[base.slice(1)].relpath+'/'+path.basename(fname));
		}
		
		  
		
       
	    fpath = pt.normalize(fpath);
		if(fpath !=='' &&fs.existsSync(fpath))
		{
		var ext = path.extname(fname);
		ext = ext.slice(1);
	 	let mime = mimeSet[ext];
		if(!mime)
		  mime = "text/plain";
	    this.outputtores(fpath, mime,req,res);
		}
		else
		{
			res.writeHead(404, { 'Content-Type': 'text/html' });
		    res.end("404 : content not found");
		}
	
		//fs.readFile(fpath, callback);
	}





}
simple_js.prototype.use = function (path, callback) {
	if (arguments.length === 1) {
		callback = path;
		path = undefined;
	}
	this.middleware.push({ function: callback, path: path });
	return this;
}

simple_js.prototype.findbyconvention = function (path) {

	var fs = require('fs');
	try {
		var ststsync = fs.statSync(path)
		return true
	}
	catch (err) {
		//console.log(err);
		return false;

	}
}

simple_js.prototype.notfound = function (resp) {
	//console.log('nf');
	resp.writeHead(404, { 'Content-Type': 'text/html' });
	resp.end("404 : content not found");
}

simple_js.prototype.isimage = function (fname, res, req, data) {image
    
	var imgexts = new Array('.jpg', '.gif', '.png', '.bmp', '.ico', '.jpeg');
    
	var ext = path.extname(fname);
    
	if (imgexts.indexOf(ext) !== -1) {
        if(ext == 'ico')
		    ext = 'x-icon'
		
		if (this.cache !== undefined && !this.cache.cacheFile(fname)) {
			
			this.cache.writemime(ext.slice(1), fname, 'image');
			// if(this.cache === undefined)
			
			this.outputtores(ext.slice(1), data, 'image', res);
		}
		if(!this.cache)
		{
			this.outputtores(ext.slice(1), data, 'image', res);
		}
		return true;
	}
	else
		return false;

}

simple_js.prototype.isstyle = function (fname, res, req, data) {

	var ext = path.extname(fname);
	var mime = 'text';
	if (ext === ".css") {
       
		if (this.cache !== undefined && !this.cache.cacheFile(fname)) {
           
			this.cache.writemime(ext.slice(1), fname, mime);
			
			// else if(this.cache !== undefined)
			this.outputtores(ext.slice(1), data, mime, res);
		}
		if(!this.cache)
		{
			this.outputtores(ext.slice(1), data, mime, res);
		}
		return true;
	}
	else
		return false;
}

simple_js.prototype.isfont = function (fname, res, req, data) {
	var fonts = new Array('.ttf', '.woff', '.otf', 'eot');

	var ext = path.extname(fname);
	var mime = 'font';
	if (fonts.indexOf(ext) !== -1) {
		// console.log(ext);	  

		if (ext === '.woff') {
			mime = 'application';
			ext = '.font-woff';
		}
		if (ext === '.eot') {
			mime = 'application';
			ext = '.vnd.ms-fontobject';
		}
		if (ext == '.otf') {
			ext = '.opentype';
		}
		if (this.cache !== undefined && !this.cache.cacheFile(fname))
			this.cache.writemime(ext.slice(1), fname, mime);
		// else if(this.cache !== undefined)
		this.outputtores(ext.slice(1), data, mime, req,res);

		return true;
	}
	else
		return false;
}
simple_js.prototype.stic = function (res, req, err, data, fname) {
	try {

		if (err)
			throw err;
		var ext = path.extname(fname);
		var mime = 'text';
		if (ext === '.json')
			mime = 'application';
	   
		if (!this.isimage(fname, res, req, data) && !this.isfont(fname, res, req, data) && !this.isstyle(fname, res, req, data)) {

			if (this.cache && !this.cache.cacheFile(fname)) {
				this.cache.writemime(ext.slice(1), fname, mime);
				this.outputtores(ext.slice(1), data, mime, res);
			}
			if(!this.cache)
			{
					this.outputtores(ext.slice(1), data, mime,req, res);
			}



			//res.end(data.toString());
		}
	}
	catch (e) {
		//console.log(e);
		res.writeHead(404, { 'Content-Type': 'text/html' });
		res.end("404 : content not found");
		//console.log(e);

	}	
}

simple_js.prototype.outputtores = function (fname, mime,req, res) {
    var fs = require('fs');
    var zlib = require('zlib');
	let acceptEncoding = compression(req,res);
	try
	{
	var raw = fs.createReadStream(fname);
	
	if (acceptEncoding.match(/\bdeflate\b/)) {
		
		res.writeHead(200, { 'content-encoding': 'deflate' , 'Content-Type': mime});
		raw.pipe(zlib.createDeflate()).pipe(res);
	}
	else if (acceptEncoding.match(/\bgzip\b/)) {
		 
			res.writeHead(200, { 'content-encoding': 'gzip' ,  'Content-Type': mime + '/' + ext });
		raw.pipe(zlib.createGzip()).res(raw);
	}
	else
	{
		
		res.writeHead(200, { 'Content-Type': mime + '/' + ext });
		raw.pipe(res);
	}
	}
	catch(err)
	{
		console.log('error :', err)
	}
}


simple_js.prototype.replacesuspicioscont = function (txt) {
	return txt.replace(/&/g, '&amp;')
		.replace(/"/g, '&quot;')
		.replace(/'/g, '&#39;')
		.replace(/</g, '&lt;')
		.replace(/>/g, '&gt;');
}





