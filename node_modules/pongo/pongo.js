'use strict'
let assert =  require('assert');
let conStr = '';

 class pongo{
  
    constructor(modelname, dboptions){
        this.MongoClient = require('mongodb').MongoClient;
        this.db = null;
        
     
        let options = conStr;
        if(process.env.NODE_ENV=== 'test')
          this.connectionString = 'mongodb://'+options.dbuser+':'+options.passwd+'@'+options.dbserver+':'+options.dbport+'/'+options.test_db;
        else
         this.connectionString = 'mongodb://'+options.dbuser+':'+options.passwd+'@'+options.dbserver+':'+options.dbport+'/'+options.db; //abuild from config;

        
        if(modelname)
          this.modelname = modelname;
        
      
    }
   setConnectionString(opts)
   {
        this.connectionString = opts;
   }
   static init(connstr)
   {
     conStr = connstr;
     
   }
   showmodelname()
   {
     console.log(this.modelname);
   }
  
    connect(callback)
    {    
          this.MongoClient.connect(this.connectionString, (err, db)=>
          {
           
           if(err)
            {
               console.log('a connection error occured: ', err);
            }
          else
          {
             
              callback(db);
          }
          });
}


removeone(cat, callback)
 {
     var res ={};
      res.success=true;
     
  this.connect((db)=>
  {
  
    var collection = db.collection(this.modelname);
    collection.deleteOne(cat,(err, results)=>{

           this.handleResult(err,results,callback);
        }
   );

 });
}

remove(cat, callback)
 {

     var res ={};
      res.success=true;
     
  this.connect((db)=>
  {
  
    var collection = db.collection(this.modelname);
    collection.remove(cat,(err, results)=>{

           this.handleResult(err,results,callback);
        }
   );

 });
 }
// delete documents where category mathes values passes in array 
removegroup(needle, catarr, callback)
{

  var conob ={};
  conob[needle]={$in:catarr}
  var res = {};
  res.success=true;
 
  this.connect( (db)=>
  {
   
    var collection = db.collection(this.modelname);
    collection.deleteMany(conob,
      (err, results) =>{
        try{
           this.handleResult(err,results,callback);
         
        
        }
        catch(error){console.log('unexpected error');}
      }
   );
  
  }
  );
  
}


insert(obj,callback)
{

  this.connect((db)=>
  {
    var res ={};
    res.success = true;
    
      
      //console.log(obj);
      var collection = db.collection(this.modelname);
      collection.insertOne(obj,{w:1}, (err, obj)=>{
        
        this.handleResult(err,obj,callback);
           
      });
    
  
  }
  );
}

insertmany(obj,callback)
{
  
  this.connect((db)=>
  {
    var res ={};
    res.success = true;
    
      var collection = db.collection(this.modelname);
      collection.insertMany(obj,{w:1}, (err, result)=>{
        
        
        this.handleResult(err,result,callback);
           
      });
    
  
  }
  );
}

updateone(cat, vals, upsert, callback)
{
 
  let callbackfunc =callback;
  if(!callback)
  {
    callbackfunc = upsert;
    upsert == false;
  }
  this.connect((db)=>
  {
      var collection = db.collection(this.modelname);
      collection.updateOne(cat, {$set: vals, $currentDate: { "lastModified": true }},{w:1,upsert:upsert}, (err,result)=>
      {
        this.handleResult(err,result,callbackfunc);
      }
      );
  }
  );
}

pushtoarray(cat, vals,array, callback)
{
  
  this.connect((db)=>
  {
   
     var collection = db.collection(this.modelname);
    var arr={};
    arr[array]={$each:vals};
   
     collection.updateOne(cat, {$push: arr }, (err,result)=>
      {
           this.handleResult(err,result,callback);
      }
      );
  }
  
  );
}

addtoarray(cat, vals,array, callback)
{
  
  this.connect((db)=>
  {
    
    var collection = db.collection(this.modelname);
    var arr={};
    arr[array]={$each:vals};
  
     collection.updateOne(cat, {$addToSet: arr }, (err,result)=>
      {
       this.handleResult(err,result,callback);
      }
      );
  }
  
  );
}

updateinarray(cat, val,upsert, callback)
{

  var callbackfunc = callback; 
   if(!callback)
   {
   
    callbackfunc = upsert;
     upsert = false;
   }
  
  this.connect((db)=>
  {
    
      var collection = db.collection(this.modelname);
      
     
     collection.update(cat, {$set: val },{upsert:upsert},(err,result)=>
      {
       if(result)
        this.handleResult(err,result,callbackfunc);
       else
         this.handleResult(err,null,callbackfunc);
      }
      );
  }
  
 
  );
}

removefromarray(cat, val,multi, callback)
{
 let callbackfunc = callback;
  if(!callback)
  {
    callbackfunc = multi;
    multi = false
  
  }
  this.connect((db)=>
  {
      var collection = db.collection(this.modelname);
      collection.update(cat, {$pull: val },{multi:multi},(err,result)=>
      {
        this.handleResult(err, result, callbackfunc);
      }
      );
  }
  
  );
}

//to continue
updateMany(cat, vals,upsert, callback)
{
 let callbackfunc = callback;
 if(!callback)
 {
    upsert == false;
    callbackfunc = upsert;
 }
 
 this.connect((db)=>
  {
    
      var collection = db.collection(this.modelname);
      collection.updateMany(cat, {$set: vals, $currentDate: { "lastModified": true }},{w:1,upsert:upsert}, (err,result)=>
      {
        this.handleResult(err,result,callbackfunc);
      }
      );
    
  });
  
}

replacefunction(id, rep, callback)
{
 
  this.connect((db)=>
  {
    
     var collection = db.collection(this.modelname);
     collection.replaceOne({'_id':id}, rep,{w:1}, function(err ,result) {
       this.handleResult(err,result,callback);
     })
  
  });
  
}

insertOrUpdate(obj,callback)
{
  
   
  this.connect((db)=>
  {
        
     var collection = db.collection(this.modelname);
      collection.save(obj,{w:1}, (err, result)=>
      {
         this.handleResult(err,result,callback);
      });
    }
  
  );
}

savetogrid(filebuff,fdata,opts,callback)
{

  var mainObj = this;
  
  var gd = require('mongodb').Grid;
  var chunkSize = opts.chunkSize;
 let callbackfunc = callback;
 if(!callback)
 {
     opts =null;
     callbackfunc = opts;
     chunkSize = 1024 * 256;;
     
 }
 
 var Grid = require('mongodb').GridStore
 this.connect((db)=>
  {
   
    var fileId = this.createObjectId();
  
    var grid = new Grid(db,fileId,fdata.filename,'w',{root:'fs', content_type:fdata.type, metadata:fdata});
    grid.chunkSize = chunkSize;
   
    grid.open((err, grid)=> {
     var Step = require('step');
     Step(
       
       function writeData() {
         var group = this.group();
      var length = filebuff.length;
  
       grid.write(filebuff, group());
   
   },

   function doneWithWrite(vdd) {
     grid.close(function(err, result) {
      
     
       if(result)
        {
        fdata.gridid = result._id;

        result.fdata = fdata;

        }
        mainObj.handleResult(err,result,callbackfunc);
        db.close();
       }
        
        
        
     );
     
   }
 )
});
});
}

streamfromgrid(fileid,bulk, callback)
{
 


 let callbackfunc = callback;
 if(!callback)
 {
     bulk = null;
     callbackfunc = bulk;
 }
 var Grid = require('mongodb').GridStore
  var ObjectId = require('mongodb').ObjectID;

 this.connect((db)=>
  {
   var grid = new Grid(db, new ObjectId(fileid),'r');
   
    grid.open((err,gs)=>
    {
    if(err)
    {
      callback(err, null,null,null);
      console.log(err);
    }
    else
    {
      
      var stream = gs.stream(true);
     
      Grid.exist(db, new ObjectId(fileid),(err, result)=> {
        if(err)
        {
            callback(err, null,null,null);
            console.log(err,'');
        }
        else
        {
        // console.log(result,'exist');
        stream.on("data", function(chunk){
         //console.log('jojo');
          //console.log(chunk.toString());
          callback(null,chunk,false,false);
        });
     
      stream.on('end', function()
      {
       console.log('end');
        callback(null, null, true,false)
      });
       stream.on('close', function(data)
      {
        console.log('closed');
         callback(null, null, true,true)
        db.close();
       
      });
        
      }
      });
      }

      
    }
    );
    }
  
  );

}

pipefromgrid(fileid, res)
{
 

  var Grid = require('mongodb').GridStore
  var ObjectId = require('mongodb').ObjectID;
 
 this.connect((db)=>
  {
   
    var grid = new Grid(db, new ObjectId(fileid),'r');
   
    grid.open(function(err,gs)
    {
    if(err)
    {
      console.log(err);
    }
    else
    {
      
      var stream = gs.stream(true);
      //.log(res);
      Grid.exist(db, new ObjectId(fileid),(err, result)=> {
        if(err)
        {
         console.log(err);
        }
        else
        {
         
          decodeURI(stream.pipe(res));
         // res.end();
        }
        });

      
    }
    });
  }
  
 );
}

streamt(fileid, callback)
{
 
  var Buffer = require('buffer');
  

  //this.MongoClient
 
 var Grid = require('mongodb').GridStore
  var ObjectId = require('mongodb').ObjectID;
   // var fid =
   
 //console.log(Grid);
 this.connect((db)=>
  {
   
      //var gridStore = new GridStore(db, new ObjectId(fileid), "w");
       Grid.read(db, new ObjectId(fileid), function(err, fileData) {
         // assert.equal(data.length, fileData.length);
         if(err)
         {
          callback(err,null);
         }
         else{
         callback(null, fileData);
          db.close();
         }
        });
   }
  
 );
  
}


getfromgrid(fileid, callback)
{
 var Grid = require('mongodb').GridStore;
 var ObjectId = require('mongodb').ObjectID;
  this.connect((db)=>
  {
  
   var grid = new Grid(db, new ObjectId(fileid),'r');
    grid.open(function(err,gs)
    {
      if(err)
      {
          callback(err, null);
      }
      else
      {

      
      
       gs.read(function(err, data) {
       
     callback(null, data);
    
  });
  }
 });
   }
  );
}





findOne(cond,flds,opt,callback)
{  
 
 var callbackfunc = callback;
 if(!opt)
 {
   opt={};
  
   callbackfunc = flds;
   flds = {};
 }
 else if(!callback)
   {   
       callbackfunc = opt;
       opt = {};
      
   }
  

  this.connect((db)=>
  {
    var collection = db.collection(this.modelname);
   
          
            collection.findOne(cond,flds,opt,(err,doc)=>
            {
                 this.handleResult(err,doc,callbackfunc);
                  db.close();
            }
            );        
    }
  );
}


findById(id,flds,opt, coll,callback)
{

  let callbackfunc = callback;
  if(!opt)
  {
     
      opt={};
      callbackfunc = flds;
      
      flds ={};
      coll = true;
      

  }
  else if(!coll)
  {
      coll=true;
      callbackfunc = opt;
      opt={};
  }
  else if(!callback)
  {
      callbackfunc = coll;
      coll = true;
  }
  
  this.connect((db)=>
  {
  
   // console.log(opt);
  
    var collection = db.collection(this.modelname);
  
     
        
        collection.find({_id:id},flds,opt).count((err,count)=>{ 
          if(err)
            {
              this.handleResult(err,null,callbackfunc);
              return;
            }
           
          if(count >0){
            
             var cursor = collection.find({_id:id},flds,opt);  
             
             var retcount = count;
             if(opt.limit !== undefined && opt.limit <=count)
              retcount = opt.limit;
              this.traverseCursor(cursor,db, callbackfunc,retcount,coll);
             
             } 
             else
             {   db.close();
                 this.handleResult(null, {},callbackfunc);
             }
        });
    
    
         ;
     
  }
  
  );
 
  
}





recordcount(callback)
{
  this.connect((db)=>
  {
   var collection = db.collection(obj.modelname);
   
  
     
      collection.find().count(function(err,count){
        {
          this.handleResult(err, count,callback);
        }
      });
   }
  );
   
}

find(cond,flds,opt, coll,callback)
{

  let callbackfunc = callback;
  if(!opt)
  {
     
      opt={};
      callbackfunc = flds;
      
      flds ={};
      coll = true;
      

  }
  else if(!coll)
  {
      coll=true;
      callbackfunc = opt;
      opt={};
  }
  else if(!callback)
  {
      callbackfunc = coll;
      coll = true;
  }
  
  this.connect((db)=>
  {
  
   // console.log(opt);
  
    var collection = db.collection(this.modelname);
  
     
        
        collection.find(cond,flds,opt).count((err,count)=>{ 
          if(err)
            {
              this.handleResult(err,null,callbackfunc);
              return;
            }
           
          if(count >0){
            
             var cursor = collection.find(cond,flds,opt);  
             
             var retcount = count;
             if(opt.limit !== undefined && opt.limit <=count)
              retcount = opt.limit;
              this.traverseCursor(cursor,db, callbackfunc,retcount,coll);
             
             } 
             else
             {   db.close();
                 this.handleResult(null, {},callbackfunc);
             }
        });
    
    
         ;
     
  }
  
  );
 
  
}

findAndSort(cond,sort,flds,coll,callback)
{
  
  
  let callbackfunc = callback;
  if(!coll)
  {
      callbackfunc = flds;
      coll=false;
      
      flds ={};
     
     

  }
  else if(!callback)
  {
  
      callbackfunc = coll;
      coll = false
  }
  
  this.connect((db)=>
  {
    var collection = db.collection(this.modelname);
        collection.find(cond,flds).count((err,count)=>{ 
         
          if(err)
            {
             
              this.handleResult(err,null,callback);
            }
          
          if(count >0){
           
             var cursor = collection.find(cond,flds).sort(sort);  
             var retcount = count;
             this.traverseCursor(cursor,db, callback,retcount,coll);
             
             } 
             else
             {   db.close();
                 this.handleResult(null,{},callback);
             }
        });
    
  }
  );
 
  
}


findAndLimit(cond,limit,flds,coll,callback)
{
  
  let callbackfunc = callback;
  if(!coll)
  {
      callbackfunc = flds;
      coll=false;
      
      flds ={};
     
     

  }
  else if(!callback)
  {
  
      callbackfunc = coll;
      coll = false
  }
 
  
  this.connect((db)=>
  {
    var collection = db.collection(this.modelname);
             var cursor = collection.find(cond,flds).limit(limit);  
             
             var retcount = limit;
             this.traverseCursor(cursor,db, callbackfunc,retcount,coll);
             
  }
  
  );
 
  
}


sortAndLimit(cond,sort,limit,flds,coll,callback)
{
 let callbackfunc = callback;
  if(!coll)
  {
      callbackfunc = flds;
      coll=false;
      
      flds ={};
     
     

  }
  else if(!callback)
  {
  
      callbackfunc = coll;
      coll = false
  }
  

  
 connect((db)=>
  {
    var collection = db.collection(this.modelname);
  
    var cursor = collection.find(cond,flds).sort(sort).limit(limit);  
             
    var retcount = limit;
             
             
    this.traverseCursor(cursor,db, callbackfunc,retcount,coll);
             
             
       
  }
  );
 
  
}

sortLimitSkip(cond,sort,limit,skip, flds,coll,callback)
{
  let callbackfunc = callback;
  if(!coll)
  {
      callbackfunc = flds;
      coll=false;
      
      flds ={};
     
     

  }
  else  if(!callback)
  {
  
      callbackfunc = coll;
      coll = false
  }
  
  this.connect((db)=>
  {
    var collection = db.collection(obj.modelname);            
    var cursor = collection.find(cond,flds).sort(sort).skip(skip).limit(limit);  
    var retcount = limit;
    this.traverseCursor(cursor,db, callbackfunc,retcount,coll);
             
  }
  );
 
  
}

aggregate(pipelineoperatiors,callback)
{
  
  this.connect((db)=>
  {
    var collection = db.collection(this.modelname);
    collection.aggregate(pipelineoperatiors).toArray(function(err,res)
          {
             this.handleResult(err,res,callback);
             
             db.close();
          }); 
        
       
            
            //obj.traverseCursor(c,db, callback,0,true);
             
             
       
    
   } 
  
  );
  
}




findall(coll, callback)
{
 
  if(!callback)
  {
    callback = coll;
    coll = true;
    
  }
 
  this.connect((db)=>
  {
    
    var collection = db.collection(this.modelname);
    collection.find().count((err,count)=>{
      if(err)
      {
       this.handleResult(err, count, callback);
       return;
       
      }
      if(count > 0)
      {
       var cussor = collection.find();
       
       
       this.traverseCursor(cussor,db, callback,count,coll);
      }
      else
      {    
       this.handleResult(null, {success:false, error:'Empty set'}, callback);
      }
     
    });
  
  }
  );
}


traverseCursor(cursor,db, callback,count,coll)
 {
  var itter = 0;
  var tmparr = new Array();
  if(count===0)
  {
    this.handleResult(null, {error:true,message:"empty"}, callback);
  }
  else{
       if(coll === true)
       {
         cursor.toArray((err,dc)=>{
         if(err !== null)
         {
             this.handleResult(err,null, callback);
            
         }
            this.handleResult(null, dc, callback);
        });
        
       
       }
       else
       {
          cursor.each((err, doc)=> {
          assert.equal(err, null);
          if(doc!==null)
	      {
          
          itter++;
           callback(err, count,itter,doc);
          }
         }
  
	     );
          if(itter == count)
            db.close();
       }
    // 
		 
	  }
	
  }
  
     
 
 
adsearch(needle, flds, opts, callback)
{
let callbackfunc = callback;
 if(!opts)
 {
   callbackfunc =  flds;
   opts={};
   opts={};
 }
 else if(!callback)
 {
   callbackfunc = opts;
   opts = {};
 }
   var res = Array();
   var ids = Array();
  // var itter = 0;
   
    
    this.find({},flds,opts, true, (doc)=>
     {
      
    try{
    
      if(needle !== undefined)
      {   
      for(var indx in doc)
      {
         for(var obj in doc[indx])
         {
         if(typeof doc[indx][obj] === 'string')
           {
             
              if(doc[indx][obj].toLowerCase().match(new RegExp(needle.toLowerCase()),"i") !==null)
              {
                
               
               
                if(ids.lastIndexOf(doc[indx]['_id']) === -1)
                   {
                      
                     // console.log((doc[indx].search(new RegExp(needle,"i"))),doc[indx]);
                       res.push(doc[indx]);
                       ids.push(doc[indx]['_id']);
                       //console.log(res);
                       break;
                   }
                }
                
              }
           }
         }
        
        callbackfunc(res);
      }
      else
      {
        callbackfunc(doc);
      }
      
     }
     catch(err)
     {
       if(err)
         console.log(err);
     }
     });
   
}

searchword(needle,batch, callback)
{
   let callbackfunc = callback;

    if(!callback)
      {
          callbackfunc = batch;
          batch = false;
      }

   var res = Array();
   var ids = Array();
  
  
   if(needle !== undefined)
   {
     this.findall((doc, count,itter)=>{
     try{
      
      for(var indx in doc)
      {
         
         if(typeof doc[indx] === 'string')
           {
              if(doc[indx].toLowerCase().match(new RegExp(needle.toLowerCase()),"i") !==null)
              {
                
            
                if(batch)
                {
                if(ids.lastIndexOf(doc['_id']) === -1)
                   {
                      
                     // console.log((doc[indx].search(new RegExp(needle,"i"))),doc[indx]);
                       res.push(doc);
                       ids.push(doc['_id']);
                       //console.log(res);
                       break;
                   }
                }
                else
                {
                  
                  callbackfunc(doc);
                  break;
                }
              }
           }
        
      }
    
      if(batch && itter === count)
      {
         
         callbackfunc(res);
      }
     }
     catch(err)
     {
       if(err)
         console.log(err);
     }
   },false);
   }
   else{
    this.findall(callback, true)
   }
}

findAndUpdateByID(lookup, obj,callback)
{
  var res = {};

  res.success=true;
   this.connect((db)=>
   {


    try{
    
     var collection = db.collection(this.modelname);
   
     collection.findAndModify(
       {_id:lookup},
       [['_id','asc']],
       {$set:obj},
       {new:true},
       (err, object)=>{
         try{
           this.handleResult(err,object,callback);
           
         }
         catch(error)
         {
           console.log(error);
          
         }
         
         }
     );
     // console.log(ret.seq);
     
    }
    catch(err){
     console.log(err);
    }
    }
  );
}


findAndUpdate(lookup, obj,upsert,callback)
{
  let callbackfunc = callback;
  if(!callback)
  {
    callbackfunc = upsert;
    upsert = false;
  }
   this.connect((db)=>
    {
    try{
    
     var collection = db.collection(this.modelname);
     let res = {};
   
     collection.findAndModify(
       lookup,
       [['_id','asc']],
       {$set:obj},
       {new:true, upsert:upsert},
       
       (err, object)=>{
         try{
          
          res = object.value;
           this.handleResult(err,res,callbackfunc);
         }
         catch(error)
         {
           console.log(error);
          
         }
         
         }
     );
     // console.log(ret.seq);
     
    }
    catch(err){
      console.log(err);
     
    }
    }
  );
}

generateNextSequence(lookup, callback)
{
  
  this.connect((db)=>
  {
    
    try{

     var collection = db.collection('counters');
     collection.findAndModify(
       
       {_id:lookup},
       [['_id','asc']],
       {$inc:{seq:1}},
       {new:true},
       (err, object)=>{
         try{
           
              this.handleResult(err,object.value.seq, callback);
             
         }
         catch(error)
         {
           console.log(error);
         }
         
         }
     );
     // console.log(ret.seq);
     
    }
    catch(err){
      console.log(err);
    }
    }
  );
}

insertcounters(counterid, callback)
{
  this.connect((db)=>
  {
    
      var collection = db.collection('counters');
      var ins = collection.insert({_id:counterid, seq:0}); 
      this.handleResult(null, ins,callback);
      
    }
    
  );
  
}
getMappedObj(obj)
{
   var temp = {};
   for(var key in obj)
   {
      temp.key = o= obj[key];
      
   }
   return temp;
}
 











handleResult(err,res, callback)
{ 


   if(err)
        {
          res={};
           res.success = false;
           res.error=err;
           callback(err,null);
        }
    else{
        
           if (callback && typeof(callback) == "function")  
           {
              callback(null, res);
           }
     }


}

createObjectId(id)
{
  var retid ='';
  try{
  var Objectid = require('mongodb').ObjectID;
  if(id ===undefined || id === '')
     retid= new Objectid();
  else
    retid = new Objectid(id);
  }
  catch(error)
  {
     console.log('an error occured');
  }
  return retid;
}
runCRUD(callback)
{
  this.connect((db)=>
  {
    
    try{
          callback(err, db);
       }
       catch(err)
    {
         console.log(err);
    }

  });
}



}

module.exports = pongo;